import re
import regex
import logging
from typing import Dict, Tuple, List, Union
from dataclasses import dataclass

from stefutil import get_logger, pl
from src.util.util_ import span_pair_overlap


__all__ = [
    'Patterns', 're_pattern2regex_pattern',
    'options2re_options',
    'is_none', 'drop_consecutive_space',
    'match_row', 'partition',
    'find_match', 'find_matches', 'find_non_overlap_matches'
]


_logger = get_logger('ReGex')


Patterns = Union[re.Pattern, regex.Pattern, List[re.Pattern], List[regex.Pattern]]
StrPatterns = Union[str, List[str]]


def _re_pattern2regex_pattern(pattern: re.Pattern) -> regex.Pattern:
    assert isinstance(pattern, re.Pattern)  # sanity check
    return regex.compile(pattern.pattern, flags=pattern.flags)


def re_pattern2regex_pattern(pattern: Patterns) -> Patterns:
    if isinstance(pattern, list):
        return [re_pattern2regex_pattern(p) for p in pattern]
    else:
        return _re_pattern2regex_pattern(pattern)


def options2re_options(options: List[str] = None) -> str:
    if len(options) == 1:
        return options[0]
    else:
        ret = '|'.join(options)
        return f'({ret})'


# e.g. `` (empty string), `None`, `none`, `no entity`, `-`
_pattern_none = re.compile(r'^(^$|N/A|None|no entity|-)$', re.IGNORECASE)


def is_none(txt: str) -> bool:
    """
    Intended for checking if a sentence or entity generated by LLM is considered none-sentence or none-entity
    """
    return _pattern_none.match(txt) is not None


def drop_consecutive_space(text: str) -> str:
    """
    Fix after-effect of dropping inline entity types: 2 consecutive spaces
        => swap to 1 space
    """
    return re.sub(r'  +', ' ', text)


def match_row(
        text: str, pattern: Union[re.Pattern, List[re.Pattern]], desc: str = None, accept_no_match: bool = False,
        log: bool = True, verbose: bool = False, logger: logging.Logger = None, **kwargs
) -> re.Match:
    logger = logger or _logger
    if not isinstance(pattern, list):
        pattern = [pattern]
    pattern = [p for p in pattern if p is not None]
    for p in pattern:
        m = p.match(text)
        if m is not None:
            if verbose:
                d_log = dict(text=text, pattern=p)
                d_log.update(kwargs)
                msg = f'Matched text w/ {pl.i(d_log, indent=True)}'
                if desc is not None:
                    msg = f'{msg} {pl.i(desc)}'
                logger.info(msg)
            return m
    # no match found
    d_log = dict(text=text, pattern=pattern)
    d_log.update(kwargs)
    msg = 'Failed to match'
    if desc is not None:
        msg = f'{msg} {pl.i(desc)}'
    msg = f'{msg} w/ {pl.i(d_log, indent=True)}'
    if accept_no_match:
        if log:
            logger.warning(msg)
    else:
        raise ValueError(msg)


# syntactic sugar for word boundary
b = r'(\b|\s|\.|,|^|$|\?|\(|\)|\'|")'  # need whitespace as boundary for e.g. `Dunkin'`


def partition(text: str, keyword: str, ignore_case: bool = False) -> Tuple[str, str, str]:
    """
    Partition `text` into 3 parts: before `keyword`, `keyword`, and after `keyword`
    """
    pat = f'{b}(?P<keyword>{re.escape(keyword)}){b}'  # enforce word boundary
    flags = re.IGNORECASE if ignore_case else 0
    m = re.search(pattern=pat, string=text, flags=flags)
    if m is None:
        raise ValueError(f'Keyword `{pl.i(keyword)}` not found in `{pl.i(text)}`')
    else:
        start, end = m.span('keyword')
        matched = text[start:end].strip()
        if ignore_case:
            assert matched.lower() == keyword.lower()  # sanity check
        else:
            assert matched == keyword
        return text[:start], matched, text[end:]


def find_match(
        text: str = None, keyword: str = None, ignore_case: bool = False, strict: bool = False, pattern: Union[Patterns, StrPatterns] = None,
        match_whole_words: bool = None
) -> List[re.Match]:
    """
    :param text:  Text
    :param keyword: A span of text to find in `text`
    :param ignore_case: Whether to ignore casing when searching for `keyword`
    :param strict: If true, raise error if `keyword` is not found in `text`
    :param pattern: If given, overrides `keyword` and `ignore_case`
    :param match_whole_words: If true, match only whole words
        Relevant only if `keyword`, instead of `pattern`, is given
    :return: List of re.Match objects
    """
    k, p = keyword is not None, pattern is not None
    assert k != p  # exactly one of `keyword` and `pattern` should be given
    if match_whole_words is None:
        # match_whole_words = True if pattern is None else False
        match_whole_words = True if keyword is not None else False  # if a string given, default to match whole words
    if pattern is None:
        if match_whole_words:  # include also at sentence beginning
            kw = rf'{b}(?P<keyword>{re.escape(keyword)}){b}'
        else:
            kw = f'(?P<keyword>{re.escape(keyword)})'
        pattern = re.compile(kw, re.IGNORECASE) if ignore_case else re.compile(kw)
        # pattern = kw  # no compiling for efficiency; seems not much difference
    elif match_whole_words:  # not supported if `pattern` is given
        raise NotImplementedError
    ret = find_non_overlap_matches(pattern=pattern, text=text, return_matches=True, accept_no_match=not strict, ignore_case=ignore_case)
    if strict and len(ret) == 0:
        raise ValueError(f'Keyword `{pl.i(keyword)}` not found in `{pl.i(text)}`')
    return ret


@dataclass
class FindMatchesOutput:
    success: bool = None
    matches: List[re.Match] = None
    keyword_matches: List[List[re.Match]] = None  # the matches corresponding to each keyword by position


def find_matches(
        text: str, keywords: Union[List[str], Tuple[str, ...]],
        ignore_case: bool = False, search_in_order: bool = False, return_all: bool = False,
        suppress_error: bool = False, verbose: bool = False
) -> FindMatchesOutput:
    """
    :param text: Text to search for `keywords`
    :param keywords: List of keywords to search for in `text`
    :param ignore_case: If true, ignore casing when searching for `keywords`
    :param search_in_order: If true, search for `keywords` in order of appearance in `text`
    :param return_all: If true, return all matches, otherwise return only the first match
        Intended for checking the simple overlapping case, see `Completion2Samples`
    :param suppress_error: If true, return no match flag if no match is found, otherwise raise error
    :param verbose: If true, log multiple-match warning
    :return: List of matches for `keywords` in `text`

    .. note:: Each keyword should appear in `text` once only, error raised otherwise
    """
    if suppress_error:
        assert search_in_order and not return_all  # intended for checking valid ordering, see `ner_dataset.py`
    ret, kw_ret = [], []

    keywords = list(keywords)
    for i, kw in enumerate(keywords):
        if search_in_order and i >= 1:
            # re match has to also match prior keywords
            # pattern: <some arbitrary chars><1st-kw><some arbitrary chars><2nd-kw>...
            pattern_str = r'^.*?'
            for j in range(i):
                pattern_str += f'{b}{re.escape(keywords[j])}{b}'
                # non-greedy match, looks for first occurrence of next keyword, so that
                # e.g. The 2 `US` in `China retaliated against US tariffs by raising tariffs on $60 billion worth of US goods.`
                # results in 2 distinct matches
                pattern_str += r'.*?'
            pattern_str += rf'{b}(?P<keyword>{re.escape(kw)}){b}'  # add word boundary since input to `find_match` is a pattern
            # pattern = re.compile(pattern_str, re.IGNORECASE) if ignore_case else re.compile(pattern_str)
            pattern = pattern_str  # prior wildcard matches seems to make compiling slow, a runtime bottleneck per stack profiling
            ms = find_match(text=text, strict=not suppress_error, pattern=pattern, match_whole_words=False, ignore_case=ignore_case)
            assert len(ms) in [0, 1]
            if suppress_error and len(ms) == 0:
                return FindMatchesOutput(success=False)
            mch = ms[0]
            ret.append(mch)
            kw_ret.append([mch])
        else:
            ms = find_match(text=text, keyword=kw, ignore_case=ignore_case, strict=True)
            if verbose and len(ms) > 1 and not return_all:
                d_log = dict(text=text, keywords=keywords, keyword=kw, n_matches_found=len(ms))
                _logger.warning(f'Keyword appears multiple times in text w/ {pl.i(d_log)}')
            # If a given keyword appears multiple times in `text`, use the first match
            if return_all:
                ret += ms
                kw_ret.append(ms)
            else:
                mch = ms[0]
                ret.append(mch)
                kw_ret.append([mch])
    return FindMatchesOutput(success=True, matches=ret, keyword_matches=kw_ret)


@dataclass
class FindNOverlapMatchesOutput:
    groups: List[str] = None
    matches: List[re.Match] = None
    pattern_map: Dict[re.Pattern, List[str]] = None


def find_non_overlap_matches(
        pattern: Patterns = None, text: str = None, return_matches: bool = False, return_match_map: bool = None,
        accept_no_match: bool = False, min_match: int = None, union_patterns: bool = False, ignore_case: bool = False
) -> Union[List[str], List[re.Match], FindNOverlapMatchesOutput]:
    """
    :param pattern: Pattern to search for in `text`
        If a list of patterns is given, try patterns in order until a pattern returns any match
    :param text: Text to search for `pattern`
    :param return_matches: If true, return list of re.Match objects, otherwise return list of matched strings
    :param return_match_map: If given, return matched strings corresponding to the given patterns
    :param accept_no_match: If true, return empty list if no match is found, otherwise raise error
    :param min_match: If given, keep trying the next match patterns until at least `min_match` matches are found
    :param union_patterns: If true, try all patterns and return all matches,
        otherwise try patterns in order until a match is found
    :param ignore_case: If true, ignore casing when searching for `pattern`
        Relevant only if `pattern` is a string
    """
    def check_return(ms_: List[re.Match]) -> bool:
        n_found = len(ms_)
        return n_found >= min_match if min_match is not None else n_found > 0
    if not isinstance(pattern, list):
        pattern = [pattern]
    # pattern = re_pattern2regex_pattern(pattern)  # for efficiency
    p_map: Dict[re.Pattern, List[str]] = dict()
    if union_patterns and len(pattern) > 1:
        ori_text = text
        ms = []

        for p in pattern:
            _ms = find_non_overlap_matches(
                pattern=p, text=text, return_matches=True, accept_no_match=True, union_patterns=False, ignore_case=ignore_case)
            p_map[p] = [m.group() for m in _ms]
            ms += _ms
            text = re.sub(p, '', text)  # drop parts of the text that have been matched

        # sanity check each span is found in the text once only
        # for mch in ms:
        #     if ori_text.count(mch.group()) != 1:
        #         sic(mch, ori_text.count(mch.group()), ori_text)
        #     assert ori_text.count(mch.group()) == 1
        idxs_strt = [ori_text.index(m.group()) for m in ms]
        spans = [(i_s, i_s + len(m.group())) for i_s, m in zip(idxs_strt, ms)]
        # sanity check no overlap
        assert all(not span_pair_overlap(s1, s2) for s1, s2 in zip(spans[:-1], spans[1:]))

        ms = sorted(ms, key=lambda m: ori_text.find(m.group()))  # sort matches by occurrence order
        assert check_return(ms)
        if return_match_map:
            return FindNOverlapMatchesOutput(groups=[m.group() for m in ms], matches=ms, pattern_map=p_map)
        else:
            return ms if return_matches else [m.group() for m in ms]
    else:
        ret = []
        for p in pattern:
            find_args = dict()
            if isinstance(p, (regex.Pattern, re.Pattern)):
                # check ignore casing matches
                if ignore_case:
                    assert p.flags & re.IGNORECASE  # sanity check
                lib = regex if isinstance(p, regex.Pattern) else re
            else:
                assert isinstance(p, str)  # sanity check
                find_args['flags'] = re.IGNORECASE if ignore_case else 0
                lib = re

            ret = list(lib.finditer(p, text, **find_args))
            # ret = lib.findall(pattern=p, string=text)  # no overlap by default
            # sic(ret)
            # if not check_return(ret):
            #     sic(p, ret, len(ret), min_match)
            if check_return(ret):
                if return_match_map:
                    p_map[p] = [m.group() for m in ret]
                    return FindNOverlapMatchesOutput(groups=[m.group() for m in ret], matches=ret, pattern_map=p_map)
                else:
                    return ret if return_matches else [m.group() for m in ret]
        if accept_no_match:
            return []
        else:
            d_log = {'min #match': min_match, '#matched': len(ret)}
            raise ValueError(f'No match found for `{pl.i(pattern)}` in `{pl.i(text)}` w/ {pl.i(d_log)}')


if __name__ == '__main__':
    from stefutil import sic

    def check_match_at_boundary():
        # text = ('South Africa Johannesburg, South Africa - South Africa,'
        #         'The South African government announced on Wednesday that it has identified a new variant of the '
        #         'COVID-19 virus, known as B.1.351, which has raised concerns among health officials.')
        # keyword = 'South Africa'
        # text = ("As a result of the study, "
        #         "coffee-related stocks saw a significant increase in value, "
        #         "with companies such as Starbucks and Dunkin' experiencing record-breaking stock prices.")
        # keyword = "Dunkin'"
        text = ('The Crew Dragon spacecraft, carrying astronauts Robert Behnken and Douglas Hurley, '
                'lifted off from Launch Pad 39A at 3:22 PM EDT, embarking on a crucial mission to the International Space Station (ISS).')
        keyword = 'International Space Station (ISS)'

        ms = find_match(text=text, keyword=keyword, match_whole_words=True)
        sic(ms)
        s, e = ms[0].span('keyword')
        sic(s, e, text[s:e])
        ms = find_match(text=text, keyword=keyword, match_whole_words=False)
        sic(ms)
        s, e = ms[0].span('keyword')
        sic(s, e, text[s:e])
    # check_match_at_boundary()

    def check_sample_match():
        s = """1. United Nations (UN) 
2. European Union (EU)
3. National Democratic Institute (NDI)
4. National Rifle Association (NRA)
5. People's Mujahedin of Iran (MEK)
6. Amnesty International
7. Council on Foreign Relations (CFR)
8. African Union (AU)
9. International Monetary Fund (IMF)
10. Greenpeace
11. World Economic Forum (WEF)
12. International Committee of the Red Cross (ICRC)
13. Organization of American States (OAS)
14. Human Rights Watch
15. Islamic State of Iraq and the Levant (ISIL)"""

        pattern = [
            re.compile(r'(?P<idx>\d+)\.\s(?P<entity>.*)\s\((?!.*[A-Z]+$)(?P<paren>.*)\)'),
            re.compile(r'(?P<idx>\d+)\.\s(?P<entity>.*)\s-\s(?P<dash>.*)'),
            re.compile(r'(?P<idx>\d+)\.\s"(?P<entity>.*)"'),
            re.compile(r'(?P<idx>\d+)\.\s(?P<entity>.*)'),
        ]
        ms: List[re.Match] = find_non_overlap_matches(pattern=pattern, text=s, return_matches=True, union_patterns=True)
        sic(ms)
        groups = [m.group() for m in ms]
        sic(groups, len(groups))
    # check_sample_match()

    def check_match_all_caps():
        s_pos = "John Ross (Cherokee chief who led the Cherokee Nation during the Trail of Tears period)"
        s_neg = "European Space Research and Technology Centre (ESTEC)"

        # pattern = re.compile(r'(?P<entity>.*)\s\((?!.*[A-Z]+$).*\)')
        pattern = re.compile(r'(?P<entity>.*).*\s\((?![A-Z]+\)).*')
        ms_pos = re.match(pattern, s_pos)
        ms_neg = re.match(pattern, s_neg)
        sic(ms_pos, ms_neg)
    # check_match_all_caps()

    def check_match_same():
        s = """'   Label: "Mikhail Baryshnikov" is the name of a specific individual. A specific person\'s name is a person entity. '
'The span is a named person entity.\n'
"""
        ms = find_match(text=s, keyword=s)
        sic(ms)
        ms = list(re.finditer(s, s))
        sic(ms)
        # assert len(ms) == 1
    # check_match_same()

    def check_match():
        txt = """1. 1994 - The year when "The Lion King" was released.
2. 2009 - The year when "Avatar" was released.
3. 1985 - The year when "Back to the Future" was released.
4. 2014 - The year when "Guardians of the Galaxy" was released.
5. 1977 - The year when "Star Wars: Episode IV - A New Hope" was released.
6. 2019 - The year when "Joker" was released.
7. 1999 - The year when "The Matrix" was released.
8. 1984 - The year when "Ghostbusters" was released.
9. 2012 - The year when "The Avengers" was released.
10. 2005 - The year when "Harry Potter and the Goblet of Fire" was released.
11. 1993 - The year when "Jurassic Park" was released.
12. 2016 - The year when "Deadpool" was released.
13. 2001 - The year when "The Lord of the Rings: The Fellowship of the Ring" was released.
14. 1975 - The year when "Jaws" was released.
15. 2018 - The year when "Black Panther" was released.
"""
        # e.g. `1. The Making of Jaws`, `2. Behind the Scenes of The Godfather`
        pattern = re.compile(r'(?P<idx>\d+)\. (?P<entity>.*) [-\u2013] the year when .*\n', re.IGNORECASE)
        ms: List[re.Match] = find_non_overlap_matches(pattern=pattern, text=txt, return_matches=True, union_patterns=True)
        sic(ms)
        ret = [m.group('entity').strip() for m in ms]
        sic(ret)
    check_match()
